<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VitalApp</title>
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180.png">
<link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152.png">
<link rel="apple-touch-icon" sizes="167x167" href="apple-touch-icon-167.png">
<link rel="apple-touch-icon" href="apple-touch-icon.png">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  html, body {
    font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif;
    margin: 10px;
    background: #f7f7f7;
    color: #222;
    overflow-anchor: none;
  }
  h1 { font-size: 1.4em; margin-bottom: 10px; }
  textarea {
    width: 100%;
    height: 80px;
    padding: 8px;
    border-radius: 8px;
    border: 1px solid #ccc;
    font-size: 15px;
    margin-bottom: 8px;
    resize: vertical;
  }
  button {
    padding: 8px 12px;
    border-radius: 8px;
    border: none;
    font-size: 14px;
    margin: 3px;
    cursor: pointer;
  }
  #start { background: #2e7d32; color: #fff; }
  #stop { background: #b71c1c; color: #fff; }
  #save { background: #1565c0; color: #fff; }
  #clear { background: #6d4c41; color: #fff; }
  #chartBox {
    background: #fff;
    border-radius: 10px;
    padding: 6px;
    margin: 12px 0;
  }
  #vitalChart {
    width: 100%;
    height: 200px; /* kompakt wie ein Aktienchart */
  }
  #timeFilters, #metricFilters {
    margin: 5px 0;
    text-align: center;
  }
  #timeFilters button, #metricFilters button {
    background: #eee;
    color: #222;
  }
  ul { list-style: none; padding: 0; }
  li {
    background: #fff;
    margin: 5px 0;
    padding: 8px;
    border-radius: 6px;
    font-size: 14px;
  }
</style>
</head>
<body>
  <h1>VitalApp</h1>

  <!-- Eingabefeld -->
  <textarea id="recognized" placeholder="Hier sprechen oder diktieren..."></textarea>

  <!-- Buttons -->
  <div>
    <button id="start">üé§ Aufnahme starten</button>
    <button id="stop">‚èπÔ∏è Aufnahme stoppen</button>
    <button id="save">üíæ Speichern</button>
    <button id="clear">üßπ Clear</button>
  </div>

  <!-- Zeit-Filter -->
  <div id="timeFilters">
    <button onclick="setRange('1w')">1W</button>
    <button onclick="setRange('1m')">1M</button>
    <button onclick="setRange('3m')">3M</button>
    <button onclick="setRange('ytd')">YTD</button>
    <button onclick="setRange('max')">Max</button>
  </div>

  <!-- Graph -->
  <div id="chartBox">
    <canvas id="vitalChart"></canvas>
  </div>

  <!-- Metrik-Filter -->
  <div id="metricFilters">
    <button onclick="setMetric('weight')">Gewicht</button>
    <button onclick="setMetric('bp')">Blutdruck</button>
    <button onclick="setMetric('pulse')">Puls</button>
  </div>

  <!-- Verlauf -->
  <h2>Gespeicherte Eintr√§ge</h2>
  <ul id="entries"></ul>

<script>
  let recognition;
  let isRecording = false;
  let vitalData = [];
  let currentMetric = "weight";
  let currentRange = "1w";

  // === Spracherkennung ===
  if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SR();
    recognition.lang = "de-DE";
    recognition.continuous = true;
    recognition.interimResults = false;

    recognition.onresult = (event) => {
      let text = "";
      for (let i = event.resultIndex; i < event.results.length; i++) {
        if (event.results[i].isFinal) {
          text += event.results[i][0].transcript + " ";
        }
      }
      document.getElementById("recognized").value += text.trim() + " ";
    };
  }

  document.getElementById("start").onclick = () => {
    if (recognition && !isRecording) {
      document.getElementById("recognized").value = "";
      recognition.start();
      isRecording = true;
    }
  };
  document.getElementById("stop").onclick = () => {
    if (recognition && isRecording) {
      recognition.stop();
      isRecording = false;
    }
  };
  document.getElementById("clear").onclick = () => {
    document.getElementById("recognized").value = "";
  };

  // === Parser ===
  function parseInput(text) {
    let gewicht = text.match(/(\d+)[,\.]?(\d*)\s?kg/);
    let bp = text.match(/(\d{2,3})\s?(zu|\/)\s?(\d{2,3})/);
    let puls = text.match(/puls\s?(\d{2,3})/i);

    return {
      date: new Date(),
      weight: gewicht ? parseFloat(gewicht[1] + "." + (gewicht[2]||"0")) : null,
      syst: bp ? parseInt(bp[1]) : null,
      diast: bp ? parseInt(bp[3]) : null,
      pulse: puls ? parseInt(puls[1]) : null
    };
  }

  // === Speichern ===
  document.getElementById("save").onclick = () => {
    const text = document.getElementById("recognized").value;
    const data = parseInput(text);
    if (data.weight || data.syst || data.pulse) {
      vitalData.push(data);
      renderEntries();
      updateChart();
    } else {
      alert("Keine Vitaldaten erkannt.");
    }
  };

  // === Verlauf ===
  function renderEntries() {
    const ul = document.getElementById("entries");
    ul.innerHTML = "";
    vitalData.forEach(d => {
      let li = document.createElement("li");
      li.textContent = `${d.date.toLocaleDateString()}: ` +
        (d.weight ? `Gewicht ${d.weight}kg ` : "") +
        (d.syst ? `Blutdruck ${d.syst}/${d.diast} ` : "") +
        (d.pulse ? `Puls ${d.pulse} bpm` : "");
      ul.appendChild(li);
    });
  }

  // === Chart Setup ===
  const ctx = document.getElementById("vitalChart").getContext("2d");
  const chart = new Chart(ctx, {
    type: "line",
    data: { labels: [], datasets: [{ data: [], borderColor: "#1565c0", tension: 0.3, fill: false, pointRadius: 3 }] },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { ticks: { autoSkip: true, maxTicksLimit: 7 } },
        y: { beginAtZero: false, ticks: { callback: v => v } }
      },
      plugins: { legend: { display: false } }
    }
  });

  function setMetric(m) { currentMetric = m; updateChart(); }
  function setRange(r) { currentRange = r; updateChart(); }

  // === Chart Update ===
  function updateChart() {
    if (vitalData.length === 0) return;

    // Daten nach Zeitraum filtern
    const now = new Date();
    let filtered = vitalData;
    if (currentRange === "1w") {
      filtered = vitalData.filter(d => (now - d.date) / (1000*60*60*24) <= 7);
    } else if (currentRange === "1m") {
      filtered = vitalData.filter(d => (now - d.date) / (1000*60*60*24) <= 31);
    } else if (currentRange === "3m") {
      filtered = vitalData.filter(d => (now - d.date) / (1000*60*60*24) <= 93);
    } else if (currentRange === "ytd") {
      filtered = vitalData.filter(d => d.date.getFullYear() === now.getFullYear());
    }

    // Labels formatieren
    let labels = filtered.map(d => {
      if (currentRange === "ytd" || currentRange === "max") {
        return `${String(d.date.getMonth()+1).padStart(2,"0")}.${String(d.date.getFullYear()).slice(2)}`;
      } else {
        return `${String(d.date.getDate()).padStart(2,"0")}.${String(d.date.getMonth()+1).padStart(2,"0")}`;
      }
    });

    // Werte ausw√§hlen
    let values = [];
    if (currentMetric === "weight") values = filtered.map(d => d.weight).filter(v => v !== null);
    if (currentMetric === "pulse") values = filtered.map(d => d.pulse).filter(v => v !== null);
    if (currentMetric === "bp") values = filtered.map(d => d.syst).filter(v => v !== null);

    chart.data.labels = labels;
    chart.data.datasets[0].data = values;

    // Y-Achse anpassen
    if (currentMetric === "weight" && values.length > 0) {
      const last = values[values.length - 1];
      chart.options.scales.y.min = last - 2;
      chart.options.scales.y.max = last + 2;
      chart.options.scales.y.ticks.stepSize = 1;
      chart.options.scales.y.ticks.callback = v => v + " kg";
    }
    if (currentMetric === "pulse" && values.length > 0) {
      const last = values[values.length - 1];
      chart.options.scales.y.min = last - 4;
      chart.options.scales.y.max = last + 4;
      chart.options.scales.y.ticks.stepSize = 2;
      chart.options.scales.y.ticks.callback = v => v + " bpm";
    }
    if (currentMetric === "bp") {
      chart.options.scales.y.min = 50;
      chart.options.scales.y.max = 200;
      chart.options.scales.y.ticks.stepSize = 25;
      chart.options.scales.y.ticks.callback = v => v;
    }

    chart.update();
  }
</script>
</body>
</html>
